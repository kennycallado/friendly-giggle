Tienes que pensar que cada acceso a la web es una petición del tipo http, esto no es relevante pero yo uso mucho el término peticiones para referirme a que un usuario accede.

Empieza por el index.php, donde llegan todas las peticiones http y dependiendo del url la aplicación guiará la petición hacia el lugar correcto (esto se llama enrutar). Esto se hace desde el index que lo primero que hace es cargar el controlador, o sea _include_ del fichero del controlador y crea una instancia. Justo debajo yo tengo la variable _$marca_, Javi en el ejercicio no lo hizo así pero es más fácil manejar la petición comprobar si desde _GET llega algo en _GET[marca], si contiene algo carga el método detalle de controlador, sino contiene nada _GET[marca] muestra la lista completa

El siguiente paso es el Controller.php, esta clase en su constructor crea un objeto repository, este es un concepto que no explicó Javi pero que aplicó en el ejercicio. El objeto repository gestiona la conexión a la base de datos, así como las diferentes peticiones a la bbdd a través de sus métodos.

Desde el controlador se crea una variable ($cervezas o $cerveza) en cada método que será accesible desde la vista, esto más adelante se usará de otra forma pero de momento solo se crea una variable que contiene el resultado de llamar a al método concreto del repositorio. Una vez obtenidos los datos que vienen del repositorio carga la vista.

La idea del patrón MVC + repositorio es que las peticiones llegan al controlador y este llama al repositorio que carga el modelo, que es la M. Por último se carga la vista correcta. Ahora le echamos un ojo al modelo.

El modelo se divide en dos ficheros, el propio modelo _CervezaModel.php_ y _CervezaRepository.php_. El primero solo contiene las propiedades de la clase y su constructor. También podría contener cualquier lógica (otros métodos) que fuesen relevantes para la clase pero que no tuvieran nada que ver con la base de datos. Por ejemplo el formato de hora que usará, en este punto obvia la propiedad _create\_at_ está para demostrar que el modelo contiene solo cuestiones que tienen que ver con los datos no con el acceso a los datos.

La parte más importante del modelo sería el repositorio, esta clase podría extender el modelo o el modelo extender del repositorio (herencia)... No lo he extendido de ninguna forma ya que no sé que sería más correcto, pero bueno sería una cuestión conceptual que no afecta a la aplicación ni al ejercicio.

Esta clase gestiona todo lo que tiene que ver con el acceso a datos, desde la conexión hasta cada método de consulta a la base de datos. Creo que Javi solo usó un método, el cual hacia la conexión y obtenía los datos que devolverá hacia el controlador. Yo he dividido la lógica un poco y he creado un método privado que realiza la conexión a la base de datos con un try catch para gestionar errores con la conexión. Lo importante es que devuelve la conexión a la base de datos, no devuelve ningún dato solo la conexión para que otros métodos desde ese punto accedan a los datos.


El resto de métodos son para el acceso a datos propiamente dicho. Por ejemplo get_ListaCervezas() realiza la petición `SELECT * FROM t_cerveza` guarda el resultado de la petición en una array que contendrá varios array assoc en la variable $rows. Gestiona el error... Después cierra la conexión y devuelve $rows. Osea este método se encarga de hacer la petición a la base de datos y ordenar los datos de una forma lógica para ser recibido en la vista. En este caso la vista recibirá el mencionado array con varios array assoc y así será más fácil iterrar.

El método get_Cerveza($marca), como ves recibe el argumento $marca, esto viene desde index.php y que a su vez fue enviado al controlador y llega hasta aquí para determinar que marca eligió el usuario. El resto del método hace lo mismo acceder a datos, pero en este caso solo construye un array assoc ya que se espera que solo exista una línea en la respuesta de la base de datos, y esta respuesta $row es enviado a controlador para que lo reciba la vista.

En vista solo tengo dos posibles vistas, una para mostrar la lista de cervezas disponible y otra vista para el detalle de la cerveza seleccionada. En las dos vistas como ves la parte de php lo que hace es iterrar con un foreach por la variable generada en el controlador $cerveza o $cervezas. Debes conocer como llegan los datos a la vista para saber como iterar por la variable.

En una vista general de la aplicación, se puede observar que todas las peticiones llegarían a index.php y en función de si llega la variable $_GET[marca] la petición se dirige en hacia uno de los métodos del controlador. El controlador se encarga de cargar el repositorio que a su ver cargaría el modelo para obtener los datos que devuelve al controlador. Una vez que el controlador obtiene estos datos carga la vista que será lo que el usuario puede ver y navegar. Con esto tenemos una aplicación que sigue el patrón MVC + repository.
